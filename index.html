<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Block Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Press+Start+2P&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #0f172a 100%);
            min-height: 100vh;
            color: #e2e8f0;
            overflow-x: hidden;
        }

        .title-font {
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 0.1em;
        }

        .grid-cell {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.5);
            position: relative;
            cursor: grab;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .grid-cell.occupied {
            cursor: default;
        }

        .block {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .block:active {
            cursor: grabbing;
        }

        .block.start-block {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            font-size: 20px;
        }

        .block.finish-block {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            font-size: 20px;
        }

        .block.arrow-left {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .block.arrow-right {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .block.rotate-left {
            background: linear-gradient(135deg, #ec4899, #be185d);
            color: white;
        }

        .block.rotate-right {
            background: linear-gradient(135deg, #ec4899, #be185d);
            color: white;
        }

        .block.water {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            color: white;
        }

        .block.boat {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
        }

        .block.music {
            background: linear-gradient(135deg, #f43f5e, #be123c);
            color: white;
        }

        .sidebar-block {
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: move;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .sidebar-block:hover {
            transform: translateX(4px);
            border-color: currentColor;
        }

        .robot {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-radius: 50%;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.5), inset -2px -2px 4px rgba(0,0,0,0.2);
            z-index: 50;
            transition: all 0.25s ease-in-out;
            pointer-events: none;
        }

        .robot::before {
            content: '‚óè';
            color: rgba(0, 0, 0, 0.3);
            font-size: 10px;
            position: absolute;
            left: 8px;
            top: 8px;
        }

        .robot.moving {
            filter: drop-shadow(0 0 12px rgba(245, 158, 11, 0.9));
            animation: pulse 0.25s ease-in-out;
        }

        .robot.has-boat::after {
            content: '‚õµ';
            position: absolute;
            font-size: 12px;
            top: -8px;
            right: -8px;
            background: rgba(139, 92, 246, 0.9);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px 60px;
            border-radius: 16px;
            font-size: 32px;
            font-weight: bold;
            z-index: 1000;
            text-align: center;
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .message.success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);
        }

        .message.failure {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4);
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .button-primary {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-family: 'Fredoka', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(6, 182, 212, 0.4);
        }

        .button-primary:active {
            transform: translateY(0);
        }

        .button-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .dragging-preview {
            opacity: 0.7;
            transform: scale(1.1);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 50px);
            gap: 0;
            background: rgba(15, 23, 42, 0.3);
            padding: 4px;
            border-radius: 8px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            margin: 0 auto;
            width: fit-content;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }

        .status-indicator.active {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.2);
        }

        /* Mobile Block Bar */
        .mobile-block-bar {
            display: none;
        }

        @media (max-width: 1024px) {
            .grid-container {
                grid-template-columns: repeat(10, 40px);
            }

            .grid-cell {
                width: 40px;
                height: 40px;
            }

            .robot {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }

            .block {
                font-size: 20px;
            }

            .mobile-block-bar {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                padding: 12px;
                background: rgba(15, 23, 42, 0.8);
                border: 2px solid rgba(148, 163, 184, 0.3);
                border-radius: 8px;
                justify-content: center;
                margin-bottom: 16px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .mobile-block-item {
                width: 44px;
                height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 8px;
                font-size: 24px;
                cursor: move;
                user-select: none;
                transition: all 0.2s ease;
                border: 2px solid transparent;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }

            .mobile-block-item:active {
                transform: scale(0.95);
            }

            .mobile-block-item:hover {
                transform: scale(1.05);
            }

            .desktop-sidebar {
                display: none;
            }

            .title-font {
                font-size: 1.5rem;
            }

            .message {
                font-size: 24px;
                padding: 30px 40px;
            }
        }

        @media (max-width: 640px) {
            .min-h-screen {
                padding: 1rem;
            }

            .grid-container {
                grid-template-columns: repeat(10, 32px);
                padding: 2px;
            }

            .grid-cell {
                width: 32px;
                height: 32px;
                border-width: 1px;
            }

            .robot {
                width: 26px;
                height: 26px;
                font-size: 14px;
            }

            .robot.has-boat::after {
                font-size: 10px;
                width: 16px;
                height: 16px;
                top: -6px;
                right: -6px;
            }

            .block {
                font-size: 16px;
            }

            .mobile-block-item {
                width: 38px;
                height: 38px;
                font-size: 20px;
            }

            .title-font {
                font-size: 1.25rem;
            }

            .button-primary {
                padding: 10px 20px;
                font-size: 12px;
            }

            .status-indicator {
                font-size: 12px;
                padding: 6px 12px;
            }

            .message {
                font-size: 20px;
                padding: 24px 32px;
            }

            .bg-slate-900\/50 {
                padding: 1rem;
            }
        }

        @media (max-width: 380px) {
            .grid-container {
                grid-template-columns: repeat(10, 28px);
            }

            .grid-cell {
                width: 28px;
                height: 28px;
            }

            .robot {
                width: 22px;
                height: 22px;
                font-size: 12px;
            }

            .block {
                font-size: 14px;
            }

            .mobile-block-item {
                width: 34px;
                height: 34px;
                font-size: 18px;
            }

            .message {
                font-size: 18px;
                padding: 20px 28px;
            }
        }
    </style>
</head>
<body>
    <div class="min-h-screen p-4 md:p-8">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
            <div class="text-center mb-4 md:mb-8">
                <h1 class="title-font text-4xl md:text-5xl mb-2" style="color: #fbbf24;">MAZE BUILDER</h1>
                <p class="text-slate-300 text-xs md:text-base">Drag blocks to build a path from Start to Finish</p>
            </div>

            <!-- Main Game Container -->
            <div class="grid grid-cols-1 lg:grid-cols-4 gap-4 lg:gap-6">
                <!-- Sidebar with Block Palette -->
                <div class="lg:col-span-1 desktop-sidebar">
                    <div class="bg-slate-900/50 backdrop-blur-sm border border-slate-700 rounded-12 p-6">
                        <h2 class="text-lg font-bold text-cyan-400 mb-4 flex items-center gap-2">
                            <span>üì¶</span> BLOCKS
                        </h2>

                        <div class="space-y-3">
                            <!-- Start Block -->
                            <div class="sidebar-block start-block" draggable="true" data-block-type="start">
                                <span>‚ñ∂</span>
                                <span>Start</span>
                            </div>

                            <!-- Finish Block -->
                            <div class="sidebar-block finish-block" draggable="true" data-block-type="finish">
                                <span>üèÅ</span>
                                <span>Finish</span>
                            </div>

                            <!-- Arrow Left -->
                            <div class="sidebar-block arrow-left" draggable="true" data-block-type="arrow-left">
                                <span>‚Üê</span>
                                <span>Left</span>
                            </div>

                            <!-- Arrow Right -->
                            <div class="sidebar-block arrow-right" draggable="true" data-block-type="arrow-right">
                                <span>‚Üí</span>
                                <span>Right</span>
                            </div>

                            <!-- Rotate Left -->
                            <div class="sidebar-block rotate-left" draggable="true" data-block-type="rotate-left">
                                <span>‚Ü∫</span>
                                <span>Rotate L</span>
                            </div>

                            <!-- Rotate Right -->
                            <div class="sidebar-block rotate-right" draggable="true" data-block-type="rotate-right">
                                <span>‚Üª</span>
                                <span>Rotate R</span>
                            </div>

                            <!-- Water -->
                            <div class="sidebar-block water" draggable="true" data-block-type="water">
                                <span>üíß</span>
                                <span>Water</span>
                            </div>

                            <!-- Boat -->
                            <div class="sidebar-block boat" draggable="true" data-block-type="boat">
                                <span>‚õµ</span>
                                <span>Boat</span>
                            </div>

                            <!-- Music -->
                            <div class="sidebar-block music" draggable="true" data-block-type="music">
                                <span>üéµ</span>
                                <span>Music</span>
                            </div>
                        </div>

                        <!-- Info Section -->
                        <div class="mt-8 pt-6 border-t border-slate-700">
                            <p class="text-xs text-slate-400 mb-4">üí° Only 1 start & 1 finish! Collect boat before water. Music plays sound & turns right!</p>
                            <button id="clearBtn" class="button-primary w-full">Clear Grid</button>
                        </div>
                    </div>
                </div>

                <!-- Game Grid and Controls -->
                <div class="lg:col-span-3">
                    <!-- Mobile Block Bar -->
                    <div class="mobile-block-bar">
                        <div class="mobile-block-item start-block" draggable="true" data-block-type="start">‚ñ∂</div>
                        <div class="mobile-block-item finish-block" draggable="true" data-block-type="finish">üèÅ</div>
                        <div class="mobile-block-item arrow-left" draggable="true" data-block-type="arrow-left">‚Üê</div>
                        <div class="mobile-block-item arrow-right" draggable="true" data-block-type="arrow-right">‚Üí</div>
                        <div class="mobile-block-item rotate-left" draggable="true" data-block-type="rotate-left">‚Ü∫</div>
                        <div class="mobile-block-item rotate-right" draggable="true" data-block-type="rotate-right">‚Üª</div>
                        <div class="mobile-block-item water" draggable="true" data-block-type="water">üíß</div>
                        <div class="mobile-block-item boat" draggable="true" data-block-type="boat">‚õµ</div>
                        <div class="mobile-block-item music" draggable="true" data-block-type="music">üéµ</div>
                    </div>
                    <!-- Status Bar -->
                    <div class="flex gap-2 md:gap-4 mb-3 md:mb-4 justify-center">
                        <div id="boatStatus" class="status-indicator">
                            <span>‚õµ</span>
                            <span>Boat: Not Collected</span>
                        </div>
                    </div>

                    <!-- Game Grid -->
                    <div class="bg-slate-900/50 backdrop-blur-sm border border-slate-700 rounded-12 p-3 md:p-6 mb-4 md:mb-6">
                        <div class="grid-container" id="gameGrid"></div>
                    </div>

                    <!-- Controls -->
                    <div class="flex gap-2 md:gap-4 justify-center flex-wrap">
                        <button id="runBtn" class="button-primary px-6 md:px-8 py-2 md:py-3 text-sm md:text-base" style="background: linear-gradient(135deg, #10b981, #059669);">
                            ‚ñ∂ RUN
                        </button>
                        <button id="resetBtn" class="button-primary px-6 md:px-8 py-2 md:py-3 text-sm md:text-base" style="background: linear-gradient(135deg, #ef4444, #dc2626);">
                            ‚Üª RESET
                        </button>
                        <button id="clearBtnMobile" class="button-primary px-6 md:px-8 py-2 md:py-3 text-sm md:text-base lg:hidden" style="background: linear-gradient(135deg, #64748b, #475569);">
                            üóëÔ∏è CLEAR
                        </button>
                    </div>

                    <!-- Instructions -->
                    <div class="mt-4 md:mt-6 bg-slate-800/50 border border-slate-700 rounded-8 p-3 md:p-4">
                        <p class="text-xs md:text-sm text-slate-400 text-center">
                            <strong class="text-cyan-400">How to Play:</strong> Drag blocks from <span class="hidden lg:inline">the sidebar</span><span class="lg:hidden">above</span> to the grid. Only one START and one FINISH allowed. Collect a boat (‚õµ) before crossing water (üíß). Music blocks (üéµ) play a sound and turn the robot right. Press RUN to begin!
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 10;
        const CELL_SIZE = 50;
        let grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
        let robotPosition = null;
        let startPosition = null;
        let isRunning = false;
        let draggedBlockType = null;
        let hasBoat = false;

        // Initialize Grid
        function initializeGrid() {
            const gameGrid = document.getElementById('gameGrid');
            gameGrid.innerHTML = '';
            grid = Array(GRID_SIZE * GRID_SIZE).fill(null);

            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('drop', (e) => handleDrop(e, i));
                cell.addEventListener('dragenter', handleDragEnter);
                cell.addEventListener('dragleave', handleDragLeave);
                gameGrid.appendChild(cell);
            }

            // Place start block at position 0 by default
            grid[0] = 'start';
            startPosition = 0;
            robotPosition = 0;
            renderGrid();
        }

        // Sidebar and mobile block drag handlers
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('sidebar-block') || e.target.classList.contains('mobile-block-item')) {
                draggedBlockType = e.target.dataset.blockType;
                e.dataTransfer.effectAllowed = 'copy';
            }
        });

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (draggedBlockType) {
                e.target.style.opacity = '0.7';
            }
        }

        function handleDragLeave(e) {
            e.target.style.opacity = '1';
        }

        function handleDrop(e, index) {
            e.preventDefault();
            e.target.style.opacity = '1';

            if (!draggedBlockType) return;

            // Check if trying to place a second start or finish block
            if (draggedBlockType === 'start') {
                const existingStart = grid.findIndex(block => block === 'start');
                if (existingStart !== -1 && existingStart !== index) {
                    showMessage('‚ùå Only one START allowed!', 'failure');
                    draggedBlockType = null;
                    return;
                }
            }

            if (draggedBlockType === 'finish') {
                const existingFinish = grid.findIndex(block => block === 'finish');
                if (existingFinish !== -1 && existingFinish !== index) {
                    showMessage('‚ùå Only one FINISH allowed!', 'failure');
                    draggedBlockType = null;
                    return;
                }
            }

            // Replace existing block if any
            if (grid[index]) {
                grid[index] = null;
            }

            grid[index] = draggedBlockType;

            // If placing start block, remember its position
            if (draggedBlockType === 'start') {
                // Remove old start block if exists
                grid = grid.map((block, i) => block === 'start' && i !== index ? null : block);
                startPosition = index;
                robotPosition = index;
            }

            draggedBlockType = null;
            renderGrid();
        }

        // Render Grid
        function renderGrid() {
            const gameGrid = document.getElementById('gameGrid');
            const cells = gameGrid.querySelectorAll('.grid-cell');

            cells.forEach((cell, index) => {
                cell.innerHTML = '';
                const blockType = grid[index];

                if (blockType) {
                    cell.classList.add('occupied');
                    const block = document.createElement('div');
                    block.className = `block ${blockType}-block`;
                    block.draggable = true;
                    block.dataset.blockType = blockType;

                    const icons = {
                        'start': '‚ñ∂',
                        'finish': 'üèÅ',
                        'arrow-left': '‚Üê',
                        'arrow-right': '‚Üí',
                        'rotate-left': '‚Ü∫',
                        'rotate-right': '‚Üª',
                        'water': 'üíß',
                        'boat': '‚õµ',
                        'music': 'üéµ'
                    };

                    block.textContent = icons[blockType] || '';

                    // Allow removal by dragging out
                    block.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'move';
                        e.target.classList.add('dragging-preview');
                    });

                    block.addEventListener('dragend', (e) => {
                        e.target.classList.remove('dragging-preview');
                    });

                    cell.appendChild(block);
                } else {
                    cell.classList.remove('occupied');
                }
            });

            // Position robot on the grid
            positionRobot();
        }

        function positionRobot() {
            if (robotPosition === null) return;

            const gameGrid = document.getElementById('gameGrid');
            const cells = gameGrid.querySelectorAll('.grid-cell');
            
            // Remove existing robot
            const existingRobot = document.getElementById('robot');
            if (existingRobot) {
                existingRobot.remove();
            }

            // Create robot
            const robot = document.createElement('div');
            robot.id = 'robot';
            robot.className = 'robot';
            if (hasBoat) {
                robot.classList.add('has-boat');
            }
            robot.textContent = 'ü§ñ';

            const cell = cells[robotPosition];
            const gameGridRect = gameGrid.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            
            // Get actual cell size from the cell element
            const actualCellSize = cellRect.width;
            const robotSize = window.innerWidth <= 380 ? 22 : window.innerWidth <= 640 ? 26 : window.innerWidth <= 1024 ? 32 : 40;
            
            // Calculate position relative to the game grid container
            const relativeLeft = cellRect.left - gameGridRect.left + (actualCellSize / 2) - (robotSize / 2);
            const relativeTop = cellRect.top - gameGridRect.top + (actualCellSize / 2) - (robotSize / 2);
            
            robot.style.left = relativeLeft + 'px';
            robot.style.top = relativeTop + 'px';
            
            gameGrid.appendChild(robot);
            
            // Add moving animation
            setTimeout(() => {
                robot.classList.add('moving');
                setTimeout(() => {
                    robot.classList.remove('moving');
                }, 250);
            }, 10);
        }

        function updateBoatStatus() {
            const boatStatus = document.getElementById('boatStatus');
            const isMobile = window.innerWidth <= 640;
            
            if (hasBoat) {
                boatStatus.innerHTML = isMobile 
                    ? '<span>‚õµ</span><span>Collected ‚úì</span>'
                    : '<span>‚õµ</span><span>Boat: Collected ‚úì</span>';
                boatStatus.classList.add('active');
            } else {
                boatStatus.innerHTML = isMobile
                    ? '<span>‚õµ</span><span>Not Collected</span>'
                    : '<span>‚õµ</span><span>Boat: Not Collected</span>';
                boatStatus.classList.remove('active');
            }
        }

        // Play sound for music block
        function playMusicSound() {
            // Create an audio context and play a musical note
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Play a happy melody (C-E-G chord)
            const notes = [261.63, 329.63, 392.00]; // C4, E4, G4
            notes.forEach((frequency, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + index * 0.15);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.15 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
            });
        }

        // Robot Movement Logic
        async function runRobot() {
            if (!startPosition && startPosition !== 0) {
                showMessage('Place a START block first!', 'failure');
                return;
            }

            if (isRunning) return;
            isRunning = true;
            hasBoat = false;
            updateBoatStatus();

            document.getElementById('runBtn').disabled = true;
            robotPosition = startPosition;
            let currentDirection = 0; // 0=right, 1=down, 2=left, 3=up
            let visitedPositions = new Set();
            let maxSteps = 200;
            let steps = 0;

            renderGrid();

            while (steps < maxSteps) {
                steps++;
                await new Promise(r => setTimeout(r, 400));

                const currentBlockType = grid[robotPosition];

                // Check if reached finish
                if (currentBlockType === 'finish') {
                    showMessage('üéâ SUCCESS!', 'success');
                    document.getElementById('runBtn').disabled = false;
                    isRunning = false;
                    return;
                }

                // Collect boat
                if (currentBlockType === 'boat') {
                    hasBoat = true;
                    updateBoatStatus();
                }

                // Check water crossing
                if (currentBlockType === 'water') {
                    if (!hasBoat) {
                        showMessage('‚ùå Need Boat to Cross Water!', 'failure');
                        document.getElementById('runBtn').disabled = false;
                        isRunning = false;
                        return;
                    }
                }

                // Handle music block - play sound and turn right
                if (currentBlockType === 'music') {
                    playMusicSound();
                    await new Promise(r => setTimeout(r, 500)); // Wait for music to play
                    currentDirection = 0; // Turn right (face right)
                }

                // Prevent infinite loops
                const posKey = robotPosition + '-' + currentDirection;
                if (visitedPositions.has(posKey)) {
                    showMessage('‚ùå Try Again!', 'failure');
                    document.getElementById('runBtn').disabled = false;
                    isRunning = false;
                    return;
                }
                visitedPositions.add(posKey);

                // Process block type
                if (currentBlockType === 'rotate-left') {
                    currentDirection = (currentDirection - 1 + 4) % 4;
                } else if (currentBlockType === 'rotate-right') {
                    currentDirection = (currentDirection + 1) % 4;
                } else if (currentBlockType === 'arrow-left') {
                    currentDirection = 2; // Face left
                } else if (currentBlockType === 'arrow-right') {
                    currentDirection = 0; // Face right
                }

                // Move forward
                const [row, col] = [Math.floor(robotPosition / GRID_SIZE), robotPosition % GRID_SIZE];
                let newRow = row;
                let newCol = col;

                if (currentDirection === 0) newCol++; // right
                else if (currentDirection === 1) newRow++; // down
                else if (currentDirection === 2) newCol--; // left
                else if (currentDirection === 3) newRow--; // up

                // Check boundaries
                if (newRow < 0 || newRow >= GRID_SIZE || newCol < 0 || newCol >= GRID_SIZE) {
                    showMessage('‚ùå Try Again!', 'failure');
                    document.getElementById('runBtn').disabled = false;
                    isRunning = false;
                    return;
                }

                const newPosition = newRow * GRID_SIZE + newCol;

                // Check if next position has a block
                if (!grid[newPosition]) {
                    showMessage('‚ùå Try Again!', 'failure');
                    document.getElementById('runBtn').disabled = false;
                    isRunning = false;
                    return;
                }

                robotPosition = newPosition;
                renderGrid();
            }

            showMessage('‚ùå Try Again!', 'failure');
            document.getElementById('runBtn').disabled = false;
            isRunning = false;
        }

        // Show message
        function showMessage(text, type) {
            const existing = document.querySelector('.message');
            if (existing) existing.remove();

            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            document.body.appendChild(message);

            setTimeout(() => {
                message.style.animation = 'popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) reverse';
                setTimeout(() => message.remove(), 400);
            }, 2000);
        }

        // Event Listeners
        document.getElementById('runBtn').addEventListener('click', runRobot);
        document.getElementById('resetBtn').addEventListener('click', () => {
            robotPosition = startPosition;
            hasBoat = false;
            updateBoatStatus();
            renderGrid();
        });
        document.getElementById('clearBtn').addEventListener('click', () => {
            grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
            // Keep start block at position 0
            grid[0] = 'start';
            startPosition = 0;
            robotPosition = 0;
            hasBoat = false;
            updateBoatStatus();
            renderGrid();
        });
        document.getElementById('clearBtnMobile').addEventListener('click', () => {
            grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
            // Keep start block at position 0
            grid[0] = 'start';
            startPosition = 0;
            robotPosition = 0;
            hasBoat = false;
            updateBoatStatus();
            renderGrid();
        });

        // Initialize
        initializeGrid();
        updateBoatStatus();
    </script>
</body>
</html>
